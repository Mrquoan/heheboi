do local v0,v1,v2=nil,0,0;function name(v3) if (v0==v3) then return v1,v2;end local ranges=gg.getRangesList(v3 or "libil2cpp.so" );for _,range in ipairs(ranges) do if (range.state=="Xa") then v1=range.start;v2=ranges[ #ranges]["end"];break;end end return v1,v2;end function hexpatch(lib,offset,hexString) name(lib);local patches={};local addressOffset=0;for byte in string.gmatch(hexString,"%S%S") do table.insert(patches,{address=v1 + offset + addressOffset ,flags=gg.TYPE_BYTE,value=byte   .. "r" ,freeze=true});addressOffset=addressOffset + 1 ;end local result=gg.addListItems(patches);gg.removeListItems(patches);gg.clearResults();if (type(result)~="string") then return true;else gg.alert(result);return false;end end local gg=gg;v=gg.getTargetInfo();L=v.label;V=v.versionName;local info=gg.getTargetInfo();local LibTable={};function isProcess64Bit() local regions=gg.getRangesList();local lastAddress=regions[ #regions]["end"];return (lastAddress>>32)~=0 ;end local ISA=isProcess64Bit();function ISAOffsets() if (ISA==false) then edi="+0x";ed="-0x";elseif (ISA==true) then edi="0x";ed="-0x";end end ISAOffsets();function ISAOffsetss() if (ISA==false) then edit="~A B "   .. edits ;elseif (ISA==true) then edit="~A8 B	 [PC,#"   .. edits   .. "]" ;end end xg={};function gets(g) gg.loadResults(end_hook);xg[g]=gg.getResults(gg.getResultsCount());gg.clearResults();end function libs(loz) liby=1;libf=0;libzz=loz;libx=gg.getRangesList(loz);for i,v in ipairs(libx) do if (libx[i].state=="Xa") then libz=loz   .. "["   .. liby   .. "].start" ;xand=gg.getRangesList(loz)[liby].start;libf=1;break;end liby=liby + 1 ;end lib=xand;end function __() xHEX=string.format("%X",aaaa);if ( #xHEX>8) then act=( #xHEX-8) + 1 ;xHEX=string.sub(xHEX,act);end edits=edi   .. xHEX ;ISAOffsetss();end function _() aaa=b-a ;xHEX=string.format("%X",aaa);if ( #xHEX>8) then act=( #xHEX-8) + 1 ;xHEX=string.sub(xHEX,act);end edits=ed   .. xHEX ;ISAOffsetss();end function endhook(cc,g) LibStart=lib;local eh={};eh[1]={address=LibStart + cc ,flags=gg.TYPE_DWORD,value=xg[g][1].value,freeze=true};gg.addListItems(eh);gg.removeListItems(eh);end function hook_void(cc,bb,g) LibStart=lib;local m={};m[1]={address=LibStart + bb ,flags=gg.TYPE_DWORD};gg.addListItems(m);a=m[1].address;gg.removeListItems(m);local p={};p[1]={address=LibStart + cc ,flags=gg.TYPE_DWORD};gg.addListItems(p);gg.loadResults(p);end_hook=gg.getResults(1);gets(g);local n={};n[1]={address=LibStart + cc ,flags=gg.TYPE_DWORD};gg.addListItems(n);b=n[1].address;gg.clearResults();gg.removeListItems(n);aaaa=a-b ;if (tonumber(aaaa)<0) then _();end if (tonumber(aaaa)>0) then __();end local n={};n[1]={address=LibStart + cc ,flags=gg.TYPE_DWORD,value=edit,freeze=true};gg.addListItems(n);gg.removeListItems(n);end function FieldMVQ(ten,offsetfield,loai) gg.clearResults();gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_OTHER );gg.setVisible(false);gg.searchNumber(":"   .. ten ,1);gg.setVisible(false);if (gg.getResultsCount()==0) then E=0;return;end local MVQu=gg.getResults(1);gg.getResults(gg.getResultsCount());gg.refineNumber(tonumber(MVQu[1].value),1);MVQu=gg.getResults(gg.getResultsCount());gg.clearResults();for i=1, #MVQu do local item=MVQu[i];item.address=item.address-1 ;item.flags=1;end MVQu=gg.getValues(MVQu);local MVQa={};local MVQaa=1;for i=1, #MVQu do local item=MVQu[i];if (item.value==0) then MVQa[MVQaa]={address=item.address,flags=1};MVQaa=MVQaa + 1 ;end end if ( #MVQa==0) then gg.clearResults();E=0;return;end for i=1, #MVQa do local item=MVQa[i];item.address=item.address +  #ten + 1 ;item.flags=1;end MVQa=gg.getValues(MVQa);local MVQs={};local MVQbb=1;for i=1, #MVQa do local item=MVQa[i];if (item.value==0) then MVQs[MVQbb]={address=item.address,flags=1};MVQbb=MVQbb + 1 ;end end if ( #MVQs==0) then gg.clearResults();E=0;return;end for i=1, #MVQs do local item=MVQs[i];item.address=item.address-#ten ;item.flags=1;end gg.loadResults(MVQs);gg.searchPointer(0);if (gg.getResultsCount()==0) then E=0;return;end MVQu=gg.getResults(gg.getResultsCount());gg.clearResults();local MVQo1,MVQo2,MVQvt;if gg.getTargetInfo().x64 then MVQo1=48;MVQo2=56;MVQvt=32;else MVQo1=24;MVQo2=28;MVQvt=4;end local ERROR=0;::TRYAGAIN::;local MVQy={};local MVQz={};for i=1, #MVQu do local item=MVQu[i];MVQy[i]={address=item.address + MVQo1 ,flags=MVQvt};MVQz[i]={address=item.address + MVQo2 ,flags=MVQvt};end MVQy=gg.getValues(MVQy);MVQz=gg.getValues(MVQz);local MVQp={};local MVQnn=1;for i=1, #MVQy do if ((MVQy[i].value==MVQz[i].value) and ( #tostring(MVQy[i].value)>=8)) then MVQp[MVQnn]=MVQy[i].value;MVQnn=MVQnn + 1 ;end end if (( #MVQp==0) and (ERROR==0)) then if gg.getTargetInfo().x64 then MVQo1=32;MVQo2=40;else MVQo1=16;MVQo2=20;end ERROR=2;goto TRYAGAIN;end if (( #MVQp==0) and (ERROR==2)) then E=0;return;end gg.setRanges(gg.REGION_ANONYMOUS);gg.clearResults();local MVQnnx=1;for i=1, #MVQp do gg.searchNumber(tonumber(MVQp[i]),MVQvt);if (gg.getResultsCount()~=0) then local MVQnn=gg.getResults(gg.getResultsCount());gg.clearResults();for j=1, #MVQnn do MVQnn[j].name="MVQ";end gg.addListItems(MVQnn);MVQnnx=MVQnnx + 1 ;end gg.clearResults();end if (MVQnnx==1) then gg.clearResults();E=0;return;end local MVQload={};local MVQremove={};MVQnn=1;MVQu=gg.getListItems();for i=1, #MVQu do if (MVQu[i].name=="MVQ") then MVQload[MVQnn]={address=MVQu[i].address + offsetfield ,flags=loai};MVQremove[MVQnn]=MVQu[i];MVQnn=MVQnn + 1 ;end end MVQload=gg.getValues(MVQload);gg.loadResults(MVQload);gg.removeListItems(MVQremove);end function search() gg.getResults(gg.getResultsCount());gg.clearResults();gg.searchNumber(x,t);end function get() gg.getResults(gg.getResultsCount());end function refine(x) gg.refineNumber(x,t,false,loai);end function freeze(dbang) bien2=gg.getResults(9999);for i,v in pairs(bien2) do bien2[i].value=dbang;bien2[i].freeze=true;end gg.addListItems(bien2);gg.clearResults();end function check() E=nil;E=gg.getResultsCount();end function edit(xxx) bien=gg.getResults(9999);for i,v in pairs(bien) do bien[i].value=xxx;bien[i].freeze=true;end gg.addListItems(bien);gg.clearResults();gg.removeListItems(bien);end b=1;w=2;d=4;f=16;q=32;e=64; end